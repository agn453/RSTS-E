1000	REM &
	REM	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! &
	REM	!!					!! &
	REM	!!	   6502 Cross Assembler         !! &
	REM	!!					!!
1010	REM	!!    A.G. Nicholson, Newcastle Uni .   !! &
	REM	!!					!! &
	REM	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! &

1020	REM &
	REM		! Version of 26-Nov-79 &

1030	EXTEND
1040	DIM SYMBOLS$(767%), &
	VALUES%(767%), &
	FLAGS%(767%), &
	SYMBOL.CHARS%(6%), &
	DELIMITER.TABLE%(3%)
1050	! -- Set up error trap routine --
1060	ON ERROR GOTO 31020 &
	\ X$=SYS(CHR$(6%)+CHR$(-7%))
1070	! -- Initialise --
1080	NUMBER.OF.SYMBOLS%=0% &
	\ SYMBOL.TABLE.SIZE%=768% &
	\ START.CPU.TIME%=TIME(1%) &
	\ LISTING.FILE$="KB:"
1090	FOR I%=1% TO 65% &
	\	READ SYMBOL$,VALUE%,FLAG.WORD% &
	\	GOSUB 2490 &
	\ NEXT I% &
	! Read in opcodes
1100	! -- Print header --
1110	OPEN LISTING.FILE$ AS FILE 1% &
	\ PRINT #1%,"6502 Cross assembler" &
	\ PRINT #1%,"#";
1120	! &

1130	! -- Get listing, source filenames --
1140	INPUT LINE #1%, SOURCE.FILE$ &
	\ SOURCE.FILE$=CVT$$(SOURCE.FILE$,-1%)
1150	! -- Check for errors only switch --
1160	ERRORS.ONLY.SWITCH%=-1% &
	\ I%=INSTR(1%,SOURCE.FILE$,"/E") &
	\ IF I% THEN SOURCE.FILE$=LEFT(SOURCE.FILE$,I%-1%)+ &
		RIGHT(SOURCE.FILE$,I%+2%) &
	\	ERRORS.ONLY.SWITCH%=0%
1170	! -- Check for symbol table listing switch --
1180	SYMBOL.TABLE.LIST.FLAG%=INSTR(1%,SOURCE.FILE$,"/S") &
	\ IF SYMBOL.TABLE.LIST.FLAG% THEN SOURCE.FILE$= &
		LEFT(SOURCE.FILE$,SYMBOL.TABLE.LIST.FLAG%-1%)+ &
		RIGHT(SOURCE.FILE$,SYMBOL.TABLE.LIST.FLAG%+2%)
1190	! -- Check for object module output switch --
1200	OBJECT.OUT.FLAG%=0% &
	\ I%=INSTR(1%,SOURCE.FILE$,"/O") &
	\ IF I% THEN SOURCE.FILE$=LEFT(SOURCE.FILE$,I%-1%)+ &
		RIGHT(SOURCE.FILE$,I%+2%) &
	\	OBJECT.OUT.FLAG%=-1%
1210	! -- Check for listing file and add default extensions --
1220	LISTING.TO.FILE.FLAG%=INSTR(1%,SOURCE.FILE$,"=") &
	\ IF LISTING.TO.FILE.FLAG% THEN LISTING.FILE$= &
		LEFT(SOURCE.FILE$,LISTING.TO.FILE.FLAG%-1%) &
	\	LISTING.FILE$=LISTING.FILE$+".LST" UNLESS &
			INSTR(1%,LISTING.FILE$,".") &
	\	SOURCE.FILE$=RIGHT(SOURCE.FILE$, &
				LISTING.TO.FILE.FLAG%+1%)
1230	SOURCE.FILE$=SOURCE.FILE$+".SRC" UNLESS &
		INSTR(1%,SOURCE.FILE$,".")
1240	PRINT #1%,"Listing output to "+ &
		LISTING.FILE$ IF LISTING.TO.FILE.FLAG%
1250	IF OBJECT.OUT.FLAG% THEN OBJECT.FILE$= &
		LEFT(SOURCE.FILE$,INSTR(1%,SOURCE.FILE$,"."))+"HEX" &
	\	PRINT #1%,"Object module to ";OBJECT.FILE$
1260	! -- Get a unique workfile name --
1270	WORK.FILE$="X65X"+MID(NUM$(100%+ASCII(SYS(CHR$(6%)+ &
			CHR$(9%)))/2%),3%,2%)+".TMP"
1280	! -- Commence assembly --
1290	GOSUB 2010 &
	\ GOSUB 3010 &
	\ X%=1% &
	\ GOSUB 3630
1300	! -- Print symbol table --
1310	GOSUB 3660 IF SYMBOL.TABLE.LIST.FLAG% &
	\ PRINT #1%
1320	! -- Finish up and exit --
1330	CLOSE 1% &
	\ IF LISTING.TO.FILE.FLAG% THEN X%=0% &
	\	GOSUB 3630
1340	PRINT "Runtime was";(TIME(1%)-START.CPU.TIME%)/10;"sec" &
	\ GOTO 32767
1350	! &

2000	&
	! -- Pass 1 Driver routine -- &

2010	ERROR.COUNT%, &
	TOTAL.BYTES%, &
	LOCATION.COUNTER%, &
	ERROR.LINE.FLAG%, &
	OPCODE.TABLE.SUBSCRIPT%=0% &
	\ PASS.NUMBER%=1% &
	\ OPEN SOURCE.FILE$ FOR INPUT AS FILE 2% &
	\ OPEN WORK.FILE$ FOR OUTPUT AS FILE 3% &
	\ PRINT #1%,"Pass 1"
2020	INPUT LINE #2%,SOURCE.LINE$ &
	\ SOURCE.LINE$=CVT$$(SOURCE.LINE$,421%) &
	\ LINE.LENGTH%=LEN(SOURCE.LINE$) &
	\ LINE.NUMBER%=LINE.NUMBER%+1%
2030	IF LINE.LENGTH%=0% OR LEFT(SOURCE.LINE$,1%)="$" THEN &
		OPCODE.TABLE.SUBSCRIPT%=-1% &
	\	GOTO 2150
2040	! -- Scan source line --
2050	GOSUB 2360 &
	\ GOSUB 2410
2060	! -- Comment line ? --
2070	IF COMMENT.DELIMITER%=1% THEN &
		OPCODE.TABLE.SUBSCRIPT%=-1% &
	\	GOTO 2150
2080	! -- Get argument field --
2090	IF COMMENT.DELIMITER% THEN ARGUMENT$= &
		CVT$$(MID(SOURCE.LINE$,OPCODE.DELIMITER%+1%, &
		COMMENT.DELIMITER%-OPCODE.DELIMITER%-1%),258%) &
	ELSE	ARGUMENT$=CVT$$(RIGHT(SOURCE.LINE$,OPCODE.DELIMITER%+1%),258%)
2100	! -- Label ? --
2110	IF LABEL.DELIMITER% THEN SYMBOL$= &
		CVT$$(LEFT(SOURCE.LINE$,LABEL.DELIMITER%-1%),128%) &
	\	VALUE%=LOCATION.COUNTER% &
	\	FLAG.WORD%=-2% &
	\	GOSUB 2490
2120	! -- Assignment ? --
2130	IF EQU.DELIMITER% THEN GOSUB 2560 &
		ELSE GOSUB 2610
2140	! -- Write to workfile --
2150	GOSUB 2770 &
	\ GOTO 2020 IF OPCODE.TABLE.SUBSCRIPT%=-1% &
	\ GOTO 2020 IF FLAGS%(OPCODE.TABLE.SUBSCRIPT%)<>1%
2160	CLOSE 2%,3% &
	\ RETURN &
	! -- End of Pass 1
2170	! &

2180	&
	! -- Determine the addressing mode &
	! -- and the number of bytes for this opcode &

2190	OP.TYPE%=SWAP%(VALUES%(OPCODE.TABLE.SUBSCRIPT%)) AND 255%
2200	IF OP.TYPE%=0% THEN BYTE.COUNT%=1% &
	\	TEMP1%=FNERROR.PRINT%("No argument required") &
			IF ARGUMENT$<>"" &
	\	RETURN
2210	IF OP.TYPE%=1% THEN BYTE.COUNT%=2% &
	\	RETURN &
	! relative branch
2220	IF OP.TYPE%=2% THEN BYTE.COUNT%=3% &
	\	RETURN &
	! transfer
2230	ARG.LENGTH%=LEN(ARGUMENT$) &
	\ IF ARG.LENGTH%=0% THEN BYTE.COUNT%=FNERROR.PRINT%( &
			"Missing argument") &
	\	OPCODE.TABLE.SUBSCRIPT%=-1% &
	\	RETURN
2240	TEMP2$=MID(ARGUMENT$,ARG.LENGTH%-2%,3%) &
	\ TEMP3$=LEFT(ARGUMENT$,1%) &
	\ IF TEMP2$=",X)" AND TEMP3$="(" THEN ADDR.MODE%=0% &
	\ 	ARGUMENT$=MID(ARGUMENT$,2%,ARG.LENGTH%-4%) &
	\	BYTE.COUNT%=2% &
	\	RETURN &
	! (ind ,X)
2250	IF TEMP2$="),Y" AND TEMP3$="(" THEN ADDR.MODE%=16% &
	\	ARGUMENT$=MID(ARGUMENT$,2%,ARG.LENGTH%-4%) &
	\	BYTE.COUNT%=2% &
	\	RETURN &
	! (ind),Y
2260	IF TEMP3$="#" THEN ADDR.MODE%=8% &
	\	ARGUMENT$=RIGHT(ARGUMENT$,2%) &
	\	BYTE.COUNT%=2% &
	\	RETURN &
	! #
2270	IF ARGUMENT$="A" THEN ADDR.MODE%=8% &
	\	BYTE.COUNT%=1% &
	\	RETURN &
	! A
2280	TEMP2$=RIGHT(TEMP2$,2%) &
	\ IF OP.TYPE%>7% AND TEMP2$=",Y" THEN TEMP2$=",X" &
	\	GOTO 2300 &
	! Convert ',Y' to ',X' for idx store and load
2290	IF TEMP2$=",Y" THEN ADDR.MODE%=24% &
	\	ARGUMENT$=LEFT(ARGUMENT$,ARG.LENGTH%-2%) &
	\	BYTE.COUNT%=3% &
	\	RETURN &
	! abs,Y
2300	IF TEMP2$<>",X" THEN 2320 &
	ELSE	ARGUMENT$=LEFT(ARGUMENT$,ARG.LENGTH%-2%) &
	\	VALUE%=FNEVALUATE.EXPR%(ARGUMENT$) &
	\	IF UNDEFINED.SYMBOL% OR ( VALUE% AND -256% ) THEN &
			ADDR.MODE%=28% &
	\		BYTE.COUNT%=3% &
	\		RETURN &
	! abs,X
2310	ADDR.MODE%=20% &
	\ BYTE.COUNT%=2% &
	\ RETURN &
	! z page,X
2320	VALUE%=FNEVALUATE.EXPR%(ARGUMENT$) &
	\ IF UNDEFINED.SYMBOL% OR ( VALUE% AND -256% ) THEN &
		ADDR.MODE%=12% &
	\	BYTE.COUNT%=3% &
	\	RETURN &
	! abs
2330	ADDR.MODE%=4% &
	\ BYTE.COUNT%=2% &
	\ RETURN &
	! zero page
2340	! &

2350	&
	! -- Scan for strings in SOURCE.LINE$ -- &

2360	DELIMITER%=-1% &
	\ TEMP2%=0%
2370	TEMP1%=INSTR(TEMP2%+1%,SOURCE.LINE$,"'") &
	\ RETURN UNLESS TEMP1%
2380	TEMP2%=INSTR(TEMP1%+1%,SOURCE.LINE$,"'") &
	\ IF TEMP2% THEN DELIMITER%=DELIMITER%+1% &
	\	IF DELIMITER%<4% THEN	DELIMITER.TABLE%(DELIMITER%)= &
			SWAP%(TEMP1% AND 255%) OR (TEMP2% AND 255%) &
	\		GOTO 2370
2390	RETURN
2400	&
	! -- Search for token delimiters -- &
	!      LABEL.DELIMITER% Label &
	!      OPCODE.DELIMITER% Opcode &
	!      COMMENT.DELIMITER% Comment &
	!      EQU.DELIMITER% Assignment &

2410	LABEL.DELIMITER%=INSTR(1%,SOURCE.LINE$,":") &
	\ LABEL.DELIMITER%=0% IF FNCHECK.SYNTAX%(LABEL.DELIMITER%) &
	\ COMMENT.DELIMITER%=0%
2420	COMMENT.DELIMITER%=INSTR(COMMENT.DELIMITER%+1%,SOURCE.LINE$,";") &
	\ GOTO 2420 IF FNCHECK.SYNTAX%(COMMENT.DELIMITER%) &
	\ LABEL.DELIMITER%=0% IF (LABEL.DELIMITER%> &
		COMMENT.DELIMITER% AND COMMENT.DELIMITER%<>0%) &
	\ OPCODE.DELIMITER%=LABEL.DELIMITER%
2430	OPCODE.DELIMITER%=OPCODE.DELIMITER%+1% &
	\ IF OPCODE.DELIMITER%>=LINE.LENGTH% THEN 2450 &
		ELSE X%=ASCII(RIGHT(SOURCE.LINE$,OPCODE.DELIMITER%)) &
	\	IF X%=9% OR X%=32% THEN 2430
2440	OPCODE.DELIMITER%=OPCODE.DELIMITER%+1% &
	\ IF OPCODE.DELIMITER%<LINE.LENGTH% THEN &
		X%=ASCII(RIGHT(SOURCE.LINE$,OPCODE.DELIMITER%)) &
	\	IF X%<>9% AND X%<>32% THEN 2440 &
			ELSE OPCODE.DELIMITER%=OPCODE.DELIMITER%-1%
2450	EQU.DELIMITER%=INSTR(1%,SOURCE.LINE$,"=") &
	\ EQU.DELIMITER%=0% IF FNCHECK.SYNTAX%(EQU.DELIMITER%) OR &
		(EQU.DELIMITER%>COMMENT.DELIMITER% AND &
		COMMENT.DELIMITER%<>0%) &
	\	OPCODE.DELIMITER%=EQU.DELIMITER% IF EQU.DELIMITER%
2460	OPCODE.DELIMITER%=COMMENT.DELIMITER%-1% IF &
		(OPCODE.DELIMITER%>=COMMENT.DELIMITER% AND &
		COMMENT.DELIMITER%<>0%) &
	\	RETURN
2470	! &

2480	&
	! Enter symbol SYMBOL$ into symbol table &
	! and its value VALUE% &

2490	IF NUMBER.OF.SYMBOLS%=SYMBOL.TABLE.SIZE% THEN &
		VALUE%=FNERROR.PRINT%("?X65 - FATAL: Symbol table overflow") &
	\	STOP &
		! Symbol table full
2500	X%=ASCII(SYMBOL$) &
	\ IF X%<>46% AND ( X%<65% OR X%>90% ) THEN &
		VALUE%=FNERROR.PRINT%("Invalid symbol = "+SYMBOL$) &
	\	RETURN &
		! Invalid symbol
2510	TEMP2%=FNHASH.SYMBOL%(SYMBOL$,SYMBOL.TABLE.SIZE%) &
	! Hash symbol
2520	IF SYMBOLS$(TEMP2%)="" THEN SYMBOLS$(TEMP2%)=SYMBOL$ &
	\	VALUES%(TEMP2%)=VALUE% &
	\	FLAGS%(TEMP2%)=FLAG.WORD% &
	\	NUMBER.OF.SYMBOLS%=NUMBER.OF.SYMBOLS%+1% &
	\	RETURN &
		! If slot empty, enter symbol, value and flagword
2530	IF SYMBOLS$(TEMP2%)=SYMBOL$ AND FLAGS%(TEMP2%)<0% THEN &
		VALUE%=FNERROR.PRINT%("Redefined symbol = "+SYMBOL$) &
	\	RETURN &
		! Multiple definition not allowed
2540	TEMP2%=FNREHASH.SYMBOL%(TEMP2%,SYMBOL.TABLE.SIZE%) &
	\ GOTO 2520
2550	&
	! -- Enter assignment -- &

2560	SYMBOL$=CVT$$(MID(SOURCE.LINE$,LABEL.DELIMITER%+1%, &
		EQU.DELIMITER%-LABEL.DELIMITER%-1%),136%) &
	\ VALUE%=FNEVALUATE.EXPR%(ARGUMENT$) &
	\ IF UNDEFINED.SYMBOL% THEN VALUE%= &
		FNERROR.PRINT%("Undefined value")
2570	IF SYMBOL$="." THEN LOCATION.COUNTER%=VALUE% &
	ELSE	IF SYMBOL$="" THEN VALUE%= &
		FNERROR.PRINT%("Missing symbol") &
		ELSE	FLAG.WORD%=-1% &
	\		GOSUB 2490
2580	OPCODE.TABLE.SUBSCRIPT%=-1% &
	\ RETURN
2590	! &

2600	&
	! -- Get opcode subscript -- &

2610	OPCODE$=CVT$$(MID(SOURCE.LINE$,LABEL.DELIMITER%+1%, &
		OPCODE.DELIMITER%-LABEL.DELIMITER%),8%) &
	\ IF OPCODE$<>"" THEN OPCODE.TABLE.SUBSCRIPT%= &
		FNHASH.SYMBOL%(OPCODE$,SYMBOL.TABLE.SIZE%) &
	ELSE	OPCODE.TABLE.SUBSCRIPT%=-1% \ RETURN
2620	IF SYMBOLS$(OPCODE.TABLE.SUBSCRIPT%)=OPCODE$ THEN RETURN &
	ELSE	IF FLAGS%(OPCODE.TABLE.SUBSCRIPT%)<0% OR &
			SYMBOLS$(OPCODE.TABLE.SUBSCRIPT%)="" THEN &
			OPCODE.TABLE.SUBSCRIPT%= &
			FNERROR.PRINT%("Invalid opcode = "+OPCODE$)-1% &
		ELSE	OPCODE.TABLE.SUBSCRIPT%= &
			FNREHASH.SYMBOL%(OPCODE.TABLE.SUBSCRIPT%, &
				SYMBOL.TABLE.SIZE%) &
	\	GOTO 2620 &
	! Check for opcode match in the symbol table &
	! If flagword < 0 then report an error else rehash
2630	RETURN
2640	&
	! -- Get address mode and check for validity &

2650	GOSUB 2190 &
	\ RETURN IF OP.TYPE%<3% &
	! O.K. if single byte, branch or transfer
2660	ON OP.TYPE%-2% GOTO &
		2670,	2680,	2690,	2700, &
		2710,	2720,	2730 &
	!	shift	accum	bit	idx cmp &
	!	inc/dec	load idx store idx
2670	RETURN IF ( ADDR.MODE%=8% AND ARGUMENT$="A" ) &
		OR ADDR.MODE%=4% OR ADDR.MODE%=20% &
		OR ADDR.MODE%=12% OR ADDR.MODE%=28% &
	\ GOTO 2740
2680	RETURN
2690	RETURN IF ADDR.MODE%=4% OR ADDR.MODE%=12% &
	\ GOTO 2740
2700	RETURN IF ADDR.MODE%>0% AND ADDR.MODE%<16% &
	\ GOTO 2740
2710	RETURN IF ADDR.MODE%=4% OR ADDR.MODE%=20% &
		OR ADDR.MODE%=12% OR ADDR.MODE%=28% &
	\ GOTO 2740
2720	RETURN UNLESS ADDR.MODE%=0% OR ADDR.MODE%=16% &
		OR ADDR.MODE%=24% &
	\ GOTO 2740
2730	RETURN IF ADDR.MODE%=4% OR ADDR.MODE%=12% &
		OR ADDR.MODE%=20%
2740	OPCODE.TABLE.SUBSCRIPT%=FNERROR.PRINT%( &
		"Illegal addressing mode")-1% &
	\ RETURN
2750	! &

2760	&
	! -- Get byte count and output to workfile -- &

2770	IF OPCODE.TABLE.SUBSCRIPT%=-1% THEN BYTE.COUNT%=0% &
	ELSE	IF FLAGS%(OPCODE.TABLE.SUBSCRIPT%)>0% THEN &
		GOSUB 2800 &
		ELSE	GOSUB 2650 &
		! Get byte count into BYTE.COUNT%
2780	PRINT #3%,LOCATION.COUNTER%;","; &
		BYTE.COUNT%;","; &
		OPCODE.TABLE.SUBSCRIPT%;","; &
		ADDR.MODE%;","; &
		ERROR.LINE.FLAG% &
	\ PRINT #3%,ARGUMENT$ &
	\ TOTAL.BYTES%=TOTAL.BYTES%+BYTE.COUNT% &
	\ LOCATION.COUNTER%=LOCATION.COUNTER%+BYTE.COUNT% &
	\ ERROR.LINE.FLAG%=0% &
	\ RETURN
2790	&
	! -- Get byte count for pseudo-op -- &

2800	ON FLAGS%(OPCODE.TABLE.SUBSCRIPT%) &
		GOTO	2890,	2820,	2820,	2820, &
			2840,	2840,	2840,	2870, &
			2890 &
	!		.END	.BYTE	.DBYTE	.WORD &
	!		.ASCII	.ASCIP	.ASCIZ	.BLKB &
	!		.LIST
2810	! -- .BYTE, .DBYTE, .WORD --
2820	TEMP1%=0% &
	\ TEMP2%=-1% &
	\ FOR BYTE.COUNT%=0% WHILE TEMP2% &
	\	TEMP1%,TEMP2%=INSTR(TEMP1%+1%,ARGUMENT$,",") &
	\ NEXT BYTE.COUNT% &
	\ BYTE.COUNT%=BYTE.COUNT%*2% IF FLAGS%(OPCODE.TABLE.SUBSCRIPT%)=3% &
		OR FLAGS%(OPCODE.TABLE.SUBSCRIPT%)=4% &
	\ RETURN
2830	! -- .ASCII, .ASCIP, .ASCIZ --
2840	TEMP1%=INSTR(2%,ARGUMENT$,LEFT(ARGUMENT$,1%)) &
	\ IF TEMP1%=0% THEN OPCODE.TABLE.SUBSCRIPT%= &
		FNERROR.PRINT%("Missing delimiter")-1% &
	ELSE	BYTE.COUNT%=TEMP1%-2%
2850	BYTE.COUNT%=BYTE.COUNT%+1% IF FLAGS%(OPCODE.TABLE.SUBSCRIPT%)=7% &
	\ RETURN
2860	! -- .BLKB
2870	BYTE.COUNT%=FNEVALUATE.EXPR%(ARGUMENT$) &
	\ RETURN
2880	! -- .LIST, .END --
2890	BYTE.COUNT%=0% &
	\ RETURN
2900	! &

3000	&
	! -- Pass 2 Driver routine -- &

3010	LINE.NUMBER%, &
	CHECKSUM%, &
	NEW.LINE.FLAG%=0% &
	\ PASS.NUMBER%=2% &
	\ LIST.FLAG%=-1% &
	\ PRINT #1%,"Pass 2" &
	\ CLOSE 1% &
	\ OPEN LISTING.FILE$ FOR OUTPUT AS FILE 1% &
	\ OPEN SOURCE.FILE$ FOR INPUT AS FILE 2% &
	\ OPEN WORK.FILE$ FOR INPUT AS FILE 3% &
	\ KILL WORK.FILE$
3020	IF OBJECT.OUT.FLAG% THEN &
		OPEN OBJECT.FILE$ FOR OUTPUT AS FILE 4% &
	\	NEW.OBJ.LINE%=0%
3030	IF ERRORS.ONLY.SWITCH% THEN PRINT #1%," Line  Addr  B1 B2 B3" &
	\	PRINT #1%
3040	INPUT #3%,LOCATION.COUNTER%, &
		BYTE.COUNT%, &
		OPCODE.TABLE.SUBSCRIPT%, &
		ADDR.MODE%, &
		ERROR.LINE.FLAG% &
	\ INPUT LINE #3%, ARGUMENT$ &
	\ ARGUMENT$=CVT$$(ARGUMENT$,4%) &
	\ INPUT LINE #2%, SOURCE.LINE$ &
	\ SOURCE.LINE$=CVT$$(SOURCE.LINE$,4%) &
	\ LINE.NUMBER%=LINE.NUMBER%+1%
3050	! -- Form object code and output to listing file --
3060	IF LEFT(SOURCE.LINE$,1%)="$" THEN &
		SOURCE.LINE$=RIGHT(SOURCE.LINE$,2%)
3070	IF OPCODE.TABLE.SUBSCRIPT%=-1% THEN GOSUB 3540 &
	\	GOTO 3040
3080	IF FLAGS%(OPCODE.TABLE.SUBSCRIPT%)=1% THEN &
		GOSUB 3130 &
	\	RETURN
3090	ADDRESS$=FNDEC.TO.HEX$(LOCATION.COUNTER%,0%) &
	\ VALUE%=VALUES%(OPCODE.TABLE.SUBSCRIPT%) &
	\ FLAG.WORD%=SWAP%(VALUE%) AND 255% &
	\ VALUE%=VALUE% AND 255%
3100	IF FLAGS%(OPCODE.TABLE.SUBSCRIPT%)>0% THEN GOSUB 3260 &
	ELSE	IF FLAG.WORD% THEN GOSUB 3170 &
		ELSE	GOSUB 3450 &
	\		GOSUB 3540
3110	GOTO 3040
3120	&
	! -- End of assembly, tidy up -- &

3130	GOSUB 3540 &
	\ PRINT #4% IF OBJECT.OUT.FLAG%
3140	CLOSE 2%,3%,4% &
	\ RETURN
3150	! &

3160	&
	! -- Process operands -- &

3170	IF FLAG.WORD%=1% THEN GOSUB 3450 &
	\	VALUE%=FNEVALUATE.EXPR%(ARGUMENT$)-LOCATION.COUNTER%-2% &
	\	VALUE%=FNERROR.PRINT%("Invalid displacement ="+NUM$(VALUE%)) &
			IF VALUE%<-128% OR VALUE%>127% &
	\	GOSUB 3470 &
	\	GOTO 3540 &
	! relative branch
3180	IF FLAG.WORD%<>2% THEN 3200 &
	ELSE	ARG.LENGTH%=LEN(ARGUMENT$) &
	\	IF LEFT(ARGUMENT$,1%)="(" AND &
			RIGHT(ARGUMENT$,ARG.LENGTH%)=")" AND &
			VALUE%=76% THEN VALUE%=VALUE%+32% &
	\		ARGUMENT$=MID(ARGUMENT$,2%,ARG.LENGTH%-2%) &
	! JMP ( )
3190	GOSUB 3450 &
	\ VALUE%=FNEVALUATE.EXPR%(ARGUMENT$) &
	\ GOSUB 3470 &
	\ GOTO 3230 &
	! transfer
3200	IF FLAG.WORD%=6% THEN &
		ADDR.MODE%=0% IF ADDR.MODE%=8% &
	! kludge for compare idx
3210	IF FLAG.WORD%=8% THEN &
		ADDR.MODE%=ADDR.MODE%+4% &
	\	ADDR.MODE%=4% IF ADDR.MODE%=12% &
	! kludge for load idx
3220	VALUE%=VALUE%+ADDR.MODE% &
	\ GOSUB 3450 &
	\ GOTO 3540 IF BYTE.COUNT%=1% &
	\ VALUE%=FNEVALUATE.EXPR%(ARGUMENT$) &
	\ GOSUB 3470 &
	\ GOTO 3540 IF BYTE.COUNT%=2%
3230	VALUE%=SWAP%(VALUE%) &
	\ GOSUB 3490 &
	\ GOTO 3540 &
	! multi mode
3240	! &

3250	&
	! -- Pseudo-ops. -- &

3260	ON FLAGS%(OPCODE.TABLE.SUBSCRIPT%) &
		GOTO	3430,	3280,	3280,	3280, &
			3340,	3340,	3340,	3410, &
			3390 &
	!		.END	.BYTE	.DBYTE	.WORD &
	!		.ASCII	.ASCIP	.ASCIZ	.BLKB &
	!		.LIST
3270	! -- .BYTE, .DBYTE, .WORD --
3280	ARGUMENT$=ARGUMENT$+"," &
	\ TEMP3%=1% &
	\ TEMP3%=2% IF FLAGS%(OPCODE.TABLE.SUBSCRIPT%)=3% &
		OR FLAGS%(OPCODE.TABLE.SUBSCRIPT%)=4% &
	\ FOR I%=1% TO BYTE.COUNT% STEP TEMP3% &
	\	ADDRESS$=FNDEC.TO.HEX$(LOCATION.COUNTER%+I%-1%,0%) &
	\	TEMP1%=INSTR(1%,ARGUMENT$,",")
3290		TEMP2%=FNEVALUATE.EXPR%(LEFT(ARGUMENT$,TEMP1%-1%)) &
	\	IF FLAGS%(OPCODE.TABLE.SUBSCRIPT%)=3% THEN &
			VALUE%=SWAP%(TEMP2%) &
	\		GOSUB 3450 &
	\		VALUE%=TEMP2% &
	\		GOSUB 3470
3300		IF FLAGS%(OPCODE.TABLE.SUBSCRIPT%)=4% THEN &
			VALUE%=SWAP%(TEMP2%) &
	\		GOSUB 3470 &
	\		VALUE%=TEMP2% &
	\		GOSUB 3450
3310		IF FLAGS%(OPCODE.TABLE.SUBSCRIPT%)=2% THEN &
			VALUE%=TEMP2% &
	\		GOSUB 3450
3320		GOSUB 3540 &
	\	ARGUMENT$=RIGHT(ARGUMENT$,TEMP1%+1%) &
	\ NEXT I% &
	\ RETURN
3330	! -- .ASCII, .ASCIP, .ASCIZ --
3340	ARGUMENT$=MID(ARGUMENT$,2%,BYTE.COUNT%) &
	\ ARGUMENT$=LEFT(ARGUMENT$,BYTE.COUNT%-1%)+CHR$(0%) &
		IF FLAGS%(OPCODE.TABLE.SUBSCRIPT%)=7% &
	\ FOR I%=1% TO BYTE.COUNT% STEP 3% &
	\	ADDRESS$=FNDEC.TO.HEX$(LOCATION.COUNTER%+I%-1%,0%) &
	\	VALUE%=FNCHAR%(I%) &
	\	GOSUB 3450 &
	\	VALUE%=FNCHAR%(I%+1%) &
	\	GOSUB 3470 IF I%+1%<=BYTE.COUNT% &
	\	VALUE%=FNCHAR%(I%+2%) &
	\	GOSUB 3490 IF I%+2%<=BYTE.COUNT% &
	\	GOSUB 3540 &
	\ NEXT I% &
	\ RETURN
3350	! &

3360	! -- Get character J% from ARGUMENT$
3370	DEF* FNCHAR%(J%) &
	\ CHAR%=ASCII(MID(ARGUMENT$,J%,1%)) &
	\ CHAR%=CHAR% OR 128% IF FLAGS%(OPCODE.TABLE.SUBSCRIPT%)=6% &
			AND J%=BYTE.COUNT% &
	\ FNCHAR%=CHAR% &
	\ FNEND &

3380	! -- .LIST --
3390	LIST.FLAG%=FNEVALUATE.EXPR%(ARGUMENT$) &
	\ ADDRESS$="" &
	\ RETURN
3400	! -- .BLKB
3410	TEMP1%=FNEVALUATE.EXPR%(ARGUMENT$) &
	\ IF OBJECT.OUT.FLAG% THEN VALUE%=0% &
	\	FOR X%=1% TO TEMP1% &
	\		GOSUB 3520 &
	\	NEXT X%
3420	GOSUB 3540
3430	RETURN
3440	&
	! -- Form B1 -- &

3450	BYTE1$=FNDEC.TO.HEX$(VALUE%,3%) &
	\ GOSUB 3520 &
	\ RETURN
3460	&
	! -- Form B2 -- &

3470	BYTE2$=FNDEC.TO.HEX$(VALUE%,3%) &
	\ GOSUB 3520 &
	\ RETURN
3480	&
	! -- Form B3 -- &

3490	BYTE3$=FNDEC.TO.HEX$(VALUE%,3%) &
	\ GOSUB 3520 &
	\ RETURN
3500	! &

3510	&
	! -- Output object and update checksum -- &

3520	OBJECT.BYTE%=VALUE% AND 255% &
	\ OBJECT.BYTE%=FNOBJECT.OUTPUT%(VALUE%) IF OBJECT.OUT.FLAG% &
	\ CHECKSUM%=CHECKSUM%+OBJECT.BYTE% &
	\ RETURN
3530	&
	! -- Output assembled code to listing file -- &

3540	GOTO 3590 UNLESS ERRORS.ONLY.SWITCH% OR ERROR.LINE.FLAG%
3550	IF ERROR.LINE.FLAG% THEN PRINT #1%,"?"; ELSE PRINT #1%," ";
3560	IF NEW.LINE.FLAG%<LINE.NUMBER% THEN &
		PRINT #1% USING "####  ",LINE.NUMBER%; &
	ELSE	PRINT #1%,"      ";
3570	PRINT #1% USING"\  \  \\ \\ \\",ADDRESS$,BYTE1$,BYTE2$,BYTE3$; &
	\ IF LIST.FLAG% AND SOURCE.LINE$<>"" THEN &
		PRINT #1%,CHR$(9%);SOURCE.LINE$ &
	ELSE	PRINT #1%
3580	! -- Set a flag, clear output strings --
3590	NEW.LINE.FLAG%=LINE.NUMBER% &
	\ ADDRESS$,BYTE1$,BYTE2$,BYTE3$,SOURCE.LINE$="" &
	\ RETURN
3600	&
	! -- Output binary byte to object file -- &

3610	DEF* FNOBJECT.OUTPUT%(X%) &
	\ OBJECT.BYTE%=X% AND 255% &
	\ PRINT #4%,FNDEC.TO.HEX$(OBJECT.BYTE%,3%); &
	\ NEW.OBJ.LINE%=NEW.OBJ.LINE%+1% &
	\ PRINT #4% IF (NEW.OBJ.LINE% AND 15%)=0% &
	\ FNOBJECT.OUTPUT%=OBJECT.BYTE% &
	\ FNEND
3620	&
	! -- Print error count, checksum -- &

3630	PRINT #X% &
	\ PRINT #X%,"Errors detected ";FNDEC.TO.HEX$(ERROR.COUNT%,0%) &
	\ PRINT #X%,"Source checksum ";FNDEC.TO.HEX$(CHECKSUM%,0%) &
	\ PRINT #X%,"Total hex bytes ";FNDEC.TO.HEX$(TOTAL.BYTES%,0%) &
	\ PRINT #X% &
	\ RETURN
3640	! &

3650	&
	! -- Print sorted symbol table -- &

3660	TEMP1%,TEMP2%=0% &
	\ NUMBER.OF.SYMBOLS%=NUMBER.OF.SYMBOLS%-66% &
	\ RETURN IF NUMBER.OF.SYMBOLS%<0%
3670	PRINT #1%," Symbol Table" &
	\ PRINT #1%
3680	TEMP1%=TEMP1%+1% WHILE FLAGS%(TEMP1%)>=0% &
	\ SYMBOLS$(TEMP2%)=SYMBOLS$(TEMP1%) &
	\ VALUES%(TEMP2%)=VALUES%(TEMP1%) &
	\ FLAGS%(TEMP2%)=FLAGS%(TEMP1%) &
	\ TEMP2%=TEMP2%+1% &
	\ TEMP1%=TEMP1%+1% &
	\ GOTO 3680 UNLESS TEMP2%=NUMBER.OF.SYMBOLS%
3690	! -- Quick sort the symbol table
3700	TEMP1%=FNQUICKSORT%(0%,NUMBER.OF.SYMBOLS%,0%,NUMBER.OF.SYMBOLS%)
3710	! -- Output to listing file --
3720	FOR I%=0% TO NUMBER.OF.SYMBOLS% &
		\ IF FLAGS%(I%)=-1% THEN S$="#" ELSE S$=" "
3730		PRINT #1% USING " \    \ \   \   ", &
			SYMBOLS$(I%),FNDEC.TO.HEX$(VALUES%(I%),0%)+S$; &
		\ PRINT #1% IF CCPOS(1%)>63% &
	\ NEXT I%
3740	PRINT #1% IF CCPOS(1%) &
	\ RETURN
3750	&
	! -- Check position of char X% in SOURCE.LINE$ using tables &
	! -- DELIMITER%(). FNCHECK.SYNTAX%=-1% means in string &

3760	DEF* FNCHECK.SYNTAX%(X%)
3770	GOTO 3790 IF DELIMITER%=-1% OR X%=0% &
	\ FOR X0%=0% TO DELIMITER% &
	\	GOTO 3790 IF X%<(SWAP%(DELIMITER.TABLE%(X0%)) AND 255%) &
	\	IF X%<(DELIMITER.TABLE%(X0%) AND 255%) THEN &
			FNCHECK.SYNTAX%=-1% &
	\		GOTO 3800
3780	NEXT X0%
3790	FNCHECK.SYNTAX%=0%
3800	FNEND
3810	! &

4000	&
	! -- Evaluate the argument expression -- &

4010	DEF* FNEVALUATE.EXPR%(X$) &
	\ UNDEFINED.SYMBOL%=0%
4020	&
	! -- Main driver routine -- &

4030	EXPR$=X$ &
	\ GOSUB 4060 &
	\ GOSUB 4080 &
	\ EXP.VAL%=TERM%
4040	GOTO 4290 UNLESS OP% &
	\ LAST.OP%=OP% &
	\ GOSUB 4060 &
	\ GOSUB 4080 &
	\ GOSUB 4190 &
	\ GOTO 4040
4050	&
	REM ! -- Scan for the next operator { ! & % + * - / } -- &

4060	EXP.FLAG%=-1% &
	\ FOR TOK.PTR%=1% TO LEN(EXPR$) &
	\	TOK.CHR$=MID(EXPR$,TOK.PTR%,1%) &
	\	EXP.FLAG%= NOT EXP.FLAG% IF TOK.CHR$="'" &
	\	OP%=INSTR(1%,"!%&*+-/",TOK.CHR$) &
	\	RETURN IF OP% AND EXP.FLAG% &
	\ NEXT TOK.PTR% &
	\ OP%=0% &
	\ TOK.PTR%=TOK.PTR%+1% &
	\ RETURN
4070	&
	! -- Get value of term -- &

4080	TERM$=LEFT(EXPR$,TOK.PTR%-1%) &
	\ EXPR$=RIGHT(EXPR$,TOK.PTR%+1%)
4090	IF TERM$="" THEN TERM%=0% &
	\	RETURN
4100	! -- H() or L() ? --
4110	TEMP1$=LEFT(TERM$,2%) &
	\ IF TEMP1$="H(" THEN EXP.FLAG%=1% &
	ELSE	IF TEMP1$="L(" THEN EXP.FLAG%=2% &
		ELSE	EXP.FLAG%=0%
4120	IF EXP.FLAG% THEN IF RIGHT(TERM$,LEN(TERM$))=")" THEN &
			TERM$=MID(TERM$,3%,LEN(TERM$)-3%) &
		ELSE	4170
4130	TEMP1$=LEFT(TERM$,1%)
4140	IF TEMP1$>="A" AND TEMP1$<="Z" THEN TERM%=FNSYMBOL.LOOKUP%(TERM$) &
	ELSE	IF TEMP1$="0" OR TEMP1$="$" THEN &
			TERM%=FNHEX.TO.DEC%(RIGHT(TERM$,2%)) &
	ELSE	IF TEMP1$>="1" AND TEMP1$<="9" THEN TERM%=VAL(TERM$) &
	ELSE	IF TEMP1$="'" THEN TERM%=ASCII(RIGHT(TERM$,2%)) &
	ELSE	IF TEMP1$="^" THEN TERM%=FNOCT.TO.DEC%(RIGHT(TERM$,2%)) &
	ELSE	IF TERM$="." THEN TERM%=LOCATION.COUNTER% &
	ELSE	4170
4150	IF EXP.FLAG%=1% THEN TERM%=SWAP%(TERM%) AND 255% &
	ELSE	IF EXP.FLAG%=2% THEN TERM%=TERM% AND 255%
4160	RETURN
4170	TERM%=FNERROR.PRINT%("Invalid term = "+TERM$) &
	\ RETURN
4180	&
	! -- Carry out the arithmetic or logical operation -- &

4190	ON LAST.OP%+1% &
		GOTO	4270,	4200,	4210,	4220, &
			4230,	4240,	4250,	4260 &
	!			or	not	and &
	!		mult	add	sub	div
4200	EXP.VAL%=EXP.VAL% OR TERM% &
	\ RETURN &
	! or
4210	EXP.VAL%=EXP.VAL%+(NOT TERM%) &
	\ RETURN &
	! not
4220	EXP.VAL%=EXP.VAL% AND TERM% &
	\ RETURN &
	! and
4230	EXP.VAL%=EXP.VAL%*TERM% &
	\ RETURN &
	! multiply
4240	EXP.VAL%=EXP.VAL%+TERM% &
	\ RETURN &
	! add
4250	EXP.VAL%=EXP.VAL%-TERM% &
	\ RETURN &
	! subtract
4260	IF TERM%=0% THEN EXP.VAL%=FNERROR.PRINT%("Division by zero") &
	ELSE	EXP.VAL%=EXP.VAL%/TERM%
4270	RETURN
4280	&
	! -- Exit with value of expression --
4290	FNEVALUATE.EXPR%=EXP.VAL%
4300	FNEND
4310	! &

4320	&
	! -- Print the given error message to the listing file &

4330	DEF* FNERROR.PRINT%(X$) &
	\ PRINT #1%,"********";X$; &
	\ IF PASS.NUMBER%=1% THEN PRINT #1%," at line";LINE.NUMBER% &
	ELSE	PRINT #1%
4340	ERROR.COUNT%=ERROR.COUNT%+1% &
	\ ERROR.LINE.FLAG%=-1% &
	\ FNERROR.PRINT%=0% &
	\ FNEND
4350	&
	! -- Look up value of symbol -- &

4360	DEF* FNSYMBOL.LOOKUP%(SYMBOL$) &
	\ X%=FNHASH.SYMBOL%(SYMBOL$,SYMBOL.TABLE.SIZE%)
4370	IF SYMBOLS$(X%)=SYMBOL$ AND FLAGS%(X%)<=0% THEN &
		FNSYMBOL.LOOKUP%=VALUES%(X%) &
	ELSE	IF SYMBOLS$(X%)="" THEN GOSUB 4390 &
		ELSE	X%=FNREHASH.SYMBOL%(X%,SYMBOL.TABLE.SIZE%) &
	\		GOTO 4370
4380	FNEND
4390	UNDEFINED.SYMBOL%=-1% &
	\ IF PASS.NUMBER%=2% THEN &
		FNSYMBOL.LOOKUP%=FNERROR.PRINT%( &
			"Undefined symbol "+SYMBOL$)
4400	RETURN
4410	&
	! -- Dec to Hex conversion -- &

4420	DEF* FNDEC.TO.HEX$(X%,D%)
4430	X$="" &
	\ FOR X1%=0% TO 3% &
	\ X0%=(X% AND (16%^(X1%+1%)-1%*(16%^X1%)))/(16%^X1%) &
	\ X0%=X0%+16% IF X0%<0% &
	\ X$=CHR$(48%+X0%)+X$ IF X0%<10% &
	\ X$=CHR$(55%+X0%)+X$ IF X0%>9% &
	\ NEXT X1% &
	\ IF D% THEN X$=MID(X$,D%,2%)
4440	FNDEC.TO.HEX$=X$
4450	FNEND
4460	&
	! -- Hex to Dec conversion -- &

4470	DEF* FNHEX.TO.DEC%(X$) &
	\ X0%=0% &
	\ FOR X1%=1% TO LEN(X$) &
	\ X2%=ASCII(MID(X$,X1%,1%)) &
	\ IF X2%<48% OR (X2%>57% AND X2%<65%) OR X2%>70% THEN &
		FNHEX.TO.DEC%=FNERROR.PRINT%("Invalid HEX constant = "+X$) &
	\	GOTO 4490
4480	X2%=X2%-48% &
	\ X2%=X2%-7% IF X2%>9% &
	\ X0%=X2%+X0%*16% &
	\ NEXT X1% &
	\ FNHEX.TO.DEC%=X0%
4490	FNEND
4500	&
	! -- Octal to Dec conversion -- &

4510	DEF* FNOCT.TO.DEC%(X$) &
	\ X0%=0% &
	\ FOR X1%=1% TO LEN(X$) &
	\ X2%=ASCII(MID(X$,X1%,1%))-48% &
	\ IF X2%<0% OR X2%>7% THEN &
		FNOCT.TO.DEC%=FNERROR.PRINT%("Invalid OCTAL constant = "+X$) &
	\	GOTO 4530
4520	X0%=X0%*8% + X2% &
	\ NEXT X1% &
	\ FNOCT.TO.DEC%=X0%
4530	FNEND
4540	&
	! -- Calculate X1% modulo X2% -- &

4550	DEF* FNMOD%(X1%,X2%) &
	\ X1%=X1%-(X1%/X2%)*X2% &
	\ X1%=X1%+X2% IF X1%<0% &
	\ FNMOD%=X1% &
	\ FNEND
4560	&
	! -- Hash symbol X$, modulo SYMBOL.TABLE.SIZE% -- &

4570	DEF* FNHASH.SYMBOL%(SYMBOL$,M%) &
	\ SYMBOL$=LEFT(SYMBOL$+"      ",6%) &
	\ CHANGE SYMBOL$ TO SYMBOL.CHARS% &
	\ SYMBOL.CHARS%(X%)=SYMBOL.CHARS%(X%)-48% FOR X%=1% TO 6% &
	\ FNHASH.SYMBOL%=FNMOD%(SYMBOL.CHARS%(1%)*23%+ &
		SYMBOL.CHARS%(2%)*19%+SYMBOL.CHARS%(3%)*17%+ &
		SYMBOL.CHARS%(4%)*13%+SYMBOL.CHARS%(5%)*11%+ &
		SYMBOL.CHARS%(6%)*7%,M%) &
	\ FNEND
4580	&
	! -- Rehash function, modulo X2% &

4590	DEF* FNREHASH.SYMBOL%(X1%,X2%)=FNMOD%(X1%+23%,X2%)
4600	&
	! -- Quick sort symbol table &

4610	! &

4620	DEF* FNQUICKSORT%(LOW%,HIGH%,I%,J%) &
	\ I%=LOW% &
	\ J%=HIGH% &
	\ X$=SYMBOLS$((HIGH%+LOW%)/2%)
4630	I%=I%+1% WHILE SYMBOLS$(I%)<X$
4640	J%=J%-1% WHILE X$<SYMBOLS$(J%)
4650	IF I%>J% THEN 4670 &
	ELSE	IF I%<>J% THEN	VALUE%=VALUES%(I%) &
	\			FLAG.WORD%=FLAGS%(I%) &
	\			SYMBOL$=SYMBOLS$(I%) &
	\			VALUES%(I%)=VALUES%(J%) &
	\			FLAGS%(I%)=FLAGS%(J%) &
	\			SYMBOLS$(I%)=SYMBOLS$(J%) &
	\			VALUES%(J%)=VALUE% &
	\			FLAGS%(J%)=FLAG.WORD% &
	\			SYMBOLS$(J%)=SYMBOL$
4660	I%=I%+1% &
	\ J%=J%-1% &
	\ IF I%<=J% THEN 4630
4670	IF LOW%<J% THEN TEMP1%=FNQUICKSORT%(LOW%,J%,LOW%,J%)
4680	IF I%<HIGH% THEN TEMP1%=FNQUICKSORT%(I%,HIGH%,I%,HIGH%)
4690	FNQUICKSORT%=-1% &
	\ FNEND
4700	! &

31000	&
	! -- Error routine -- &

31010	! -- No ".END" --
31020	IF ERR=11% AND ERL=2020% THEN OPCODE.TABLE.SUBSCRIPT%= &
		FNERROR.PRINT%("Missing .END")+ &
			FNHASH.SYMBOL%(".END",SYMBOL.TABLE.SIZE%) &
	\	SOURCE.LINE$="" &
	\	RESUME 2150
31030	IF ERR=11% AND ERL=3040% THEN SOURCE.LINE$="" &
	\	OPCODE.TABLE.SUBSCRIPT%=FNHASH.SYMBOL%(".END", &
			SYMBOL.TABLE.SIZE%) &
	\	RESUME 3080
31040	! -- ^Z at filename request --
31050	RESUME 32767 IF ERL=1140%
31060	! -- Illegal number in FNEVALUATE.EXPR%() --
31070	IF ERR=51% AND ERL=4140% THEN X0%=VAL(TERM$)-65536 &
	\	RESUME 4150
31080	RESUME 4170 IF ERR=52% AND ERL=4140%
31090	CLOSE 1%,2%,3%,4% &
	\ RESUME 32767% IF ERR=28%
31100	! -- Print any unanticipated error --
31110	ON ERROR GOTO 0
31120	! &

32000	&
	! -- Opcode data &

32010	! Table is of the form: &
	!  SYMBOL,value,flag &
	! where: the low byte of value is the opcode base &
	!	and the high byte a flag indicating the &
	!	instruction type. flag is used by the &
	!	symbol table routines &
	!
32020	! Assembler pseudo-ops
32030	DATA	.END,	0,	1,	.BYTE,	0,	2, &
		.DBYTE,	0,	3,	.WORD,	0,	4, &
		.ASCII,	0,	5,	.ASCIP,	0,	6, &
		.ASCIZ,	0,	7,	.BLKB,	0,	8, &
		.LIST,	0,	9
32040	! Single byte instructions
32050	DATA	BRK,	0,	0,	CLC,	24,	0, &
		CLD,	216,	0,	CLI,	88,	0, &
		CLV,	184,	0,	DEX,	202,	0, &
		DEY,	136,	0,	INX,	232,	0, &
		INY,	200,	0,	NOP,	234,	0, &
		PHA,	72,	0,	PHP,	8,	0, &
		PLA,	104,	0,	PLP,	40,	0, &
		RTI,	64,	0,	RTS,	96,	0, &
		SEC,	56,	0,	SED,	248,	0, &
		SEI,	120,	0,	TAX,	170,	0, &
		TAY,	168,	0,	TSX,	186,	0, &
		TXA,	138,	0,	TYA,	152,	0, &
		TXS,	154,	0
32060	! Two byte relative branches
32070	DATA	BCC,	400,	0,	BCS,	432,	0, &
		BEQ,	496,	0,	BMI,	304,	0, &
		BNE,	464,	0,	BPL,	272,	0, &
		BVC,	336,	0,	BVS,	368,	0
32080	! Three byte transfer
32090	DATA	JMP,	588,	0,	JSR,	544,	0
32100	! Shifts and rotates
32110	DATA	ASL,	770,	0,	LSR,	834,	0, &
		ROL,	802,	0,	ROR,	866,	0
32120	! Accumulator
32130	DATA	ADC,	1121,	0,	AND,	1057,	0, &
		CMP,	1217,	0,	EOR,	1089,	0, &
		LDA,	1185,	0,	ORA,	1025,	0, &
		SBC,	1249,	0,	STA,	1153,	0
32140	! Bit test
32150	DATA	BIT,	1312,	0
32160	! Compare index
32170	DATA	CPX,	1760,	0,	CPY,	1728,	0
32180	! Increment, Decrement
32190	DATA	DEC,	1986,	0,	INC,	2018,	0
32200	! Index load
32210	DATA	LDX,	2206,	0,	LDY,	2204,	0
32220	! Index store
32230	DATA	STX,	2434,	0,	STY,	2432,	0
32767	END
